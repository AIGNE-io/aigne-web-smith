/**
 * ===================== Compose Pages Data (Refactored) =====================
 *
 * ## ÁõÆÊ†á
 * - Ê≠£Á°ÆËß£ÊûêÂπ∂Ê∏≤Êüì `LIST_KEY.*` Â±ÇÁ∫ßÔºölayout-block Ê®°ÊùøÈáåÂá∫Áé∞ÁöÑ `{{LIST_KEY.N}}` Âç†‰ΩçÔºåÂøÖÈ°ªÁî±ÂØπÂ∫î
 *   ÁöÑ list Â≠êÈ°πÂÆû‰æã **Á≤æÁ°ÆÊõøÊç¢**ÔºåËÄå‰∏çÊòØÂπ≥Èì∫Âà∞Áà∂ËäÇÁÇπÂ§ñÂ±ÇÊàñÈöèÊÑè append„ÄÇ
 * - ÂÖ®Â±Ä‰∏ÄËá¥ÁöÑ id Êò†Â∞ÑÔºöÊó†ËÆ∫ id Âá∫Áé∞Âú® sections„ÄÅsectionIds„ÄÅconfig.gridSettings ÊàñÂÖ∂‰ªñÈÖçÁΩÆ key/valueÔºå
 *   ÈÉΩÈÄöËøáÂêå‰∏ÄÂ•ó `applyIdMapDeep` ÂÆåÊàê‰∏ÄÊ¨°ÊÄßÊõøÊç¢ÔºåÈÅøÂÖç‚ÄúË°•‰∏ÅÂºè‚ÄùÈÅóÊºè„ÄÇ
 * - ÂèØÁª¥Êä§ÊÄßÔºöÊää‚Äúclone ‚Üí ÁîüÊàê idMap ‚Üí Áªü‰∏ÄÊõøÊç¢ ‚Üí ÈÄíÂΩíÊèíÊßΩÊõøÊç¢‚ÄùÁöÑÊµÅÁ®ãÂçïÁÇπÂÆûÁé∞ÔºõÈÄíÂΩíÂ§ÑÁêÜÊó∂Áà∂Â≠êËÅåË¥£Ê∏ÖÊô∞„ÄÇ
 *
 * ## Ê†∏ÂøÉÊµÅÁ®ã
 * 1) ËØªÂÖ• middle Ê†ºÂºèÔºàÊîØÊåÅÂ§öËØ≠Ë®ÄÔºâ„ÄÇ
 * 2) ÊûÑÂª∫ **Ê†ëÂΩ¢** section ËäÇÁÇπÔºà‰ªÖÊääÁúüÂÆûÁöÑ `section[list]` ÂΩì‰ΩúÂ≠êËäÇÁÇπÔºõÂêçÂ≠óÂΩ¢Â¶Ç `{{list.N}}` ÁöÑÂè™ÊòØÊ®°ÊùøÂç†‰ΩçÔºå‰∏çÁÆóÂ≠êËäÇÁÇπÔºâ„ÄÇ
 * 3) ÈÄíÂΩíÂ§ÑÁêÜÊØè‰∏™ËäÇÁÇπÔºö
 *    - ‰æùÊçÆ fieldCombinations ÂåπÈÖçÁªÑ‰ª∂Ê®°ÊùøÔºõ
 *    - clone Ê®°Êùø ‚Üí ÁîüÊàêÁ®≥ÂÆö idÔºàÂåÖÂê´ pathÔºâ‚Üí ÂΩ¢Êàê `idMap`Ôºõ
 *    - Áî® `applyIdMapDeep` ÂØπ clone ÂêéÁöÑ sectionÔºàÂê´ config/sections/sectionIdsÔºâÁªü‰∏ÄÊõøÊç¢ idÔºõ
 *    - ÂØπÁà∂ÂÆû‰æãÔºö**Êî∂ÈõÜ layout-block Âç†‰ΩçÔºà{{list.N}}Ôºâ**ÔºåÊåâÂ≠êËäÇÁÇπÁöÑ N **Âú®Áà∂ÂÆû‰æãÂÜÖ**Á≤æÁ°ÆÊõøÊç¢ slotÔºõ
 *      ÂêåÊó∂Áî® `applyIdMapDeep` ÊääÁà∂ÂÆû‰æã config ‰∏≠ÂØπÂç†‰Ωç id ÁöÑÂºïÁî®ÊõøÊç¢‰∏∫Â≠êÂÆû‰æã idÔºà‰øùËØÅ gridSettings Á≠âÂêåÊ≠•Ôºâ„ÄÇ
 * 4) ÊûÑÂª∫ÊúÄÁªà YAMLÔºöÈ°∂Â±Ç‰ªÖÊåÇ **Ê†πËäÇÁÇπÂÆû‰æã**ÔºõÊâÄÊúâÊï∞ÊçÆÊ∫ê dataSource Áªü‰∏ÄÂú®Â§ñÂ±ÇËÅöÂêà„ÄÇ
 *
 * ## ÂÖ≥ÈîÆ‰øùËØÅ
 * - **Â±ÇÁ∫ß**ÔºöÂè™Âú®Áà∂ÂÆû‰æãÊâæÂà∞‰∏é `child.path` ÂØπÂ∫îÁöÑ slotÔºà`{{list.N}}`ÔºâÊó∂ÊâçÊåÇÂÖ•Ôºõ
 *   Ëã•Êâæ‰∏çÂà∞ slotÔºåËÆ∞ÂΩï warningÔºåÂπ∂ **‰∏çÊääÂ≠êÂÆû‰æãÊèêÂçáÂà∞È°∂Â±Ç**ÔºàÈÅøÂÖç‚ÄúË∑ëÂ§ñÈù¢Âéª‚ÄùÔºâ„ÄÇ
 * - **id ‰∏ÄËá¥ÊÄß**ÔºöÂîØ‰∏ÄÊñπÊ≥ï `applyIdMapDeep` Áªü‰∏ÄÊõøÊç¢‰ªªÊÑèÂØπË±°ÁöÑ key/ÂÄºÈáåÁöÑÊóß id ‚Üí Êñ∞ id„ÄÇ
 */

import { readFileSync, rmSync } from "node:fs";
import { basename, join } from "node:path";
import _ from "lodash";
import { parse, stringify } from "yaml";
import { LIST_KEY } from "../../../utils/constants.mjs";
import {
  extractFieldCombinations,
  generateDeterministicId,
} from "../../../utils/generate-helper.mjs";
import savePagesKitData from "./save-pages-data.mjs";

// ============= Logging =============
const ENABLE_LOGS = process.env.ENABLE_LOGS === "true";
const log = (...args) => ENABLE_LOGS && console.log(...args);
const logError = (...args) => ENABLE_LOGS && console.error(...args);

// Â∞èÂ∑•ÂÖ∑Ôºöpath Êï∞ÁªÑÂèØËßÜÂåñ
const fmtPath = (p) => (Array.isArray(p) ? p.join(" ‚Ä∫ ") : String(p ?? ""));

// ============= IO Utils =============
async function readMiddleFormatFile(tmpDir, locale, fileName) {
  try {
    const filePath = join(tmpDir, locale, fileName);
    const content = readFileSync(filePath, "utf8");
    log("üì• [readMiddleFormatFile] loaded:", { locale, fileName, bytes: content.length });
    return parse(content);
  } catch (err) {
    logError("‚ö†Ô∏è  [readMiddleFormatFile] failed:", { locale, fileName, error: err.message });
    return null;
  }
}

// ============= Simple Template ============
function getNestedValue(obj, path) {
  return path.split(".").reduce((cur, key) => (cur ? cur[key] : undefined), obj);
}
function processSimpleTemplate(obj, data) {
  if (typeof obj === "string") {
    return obj.replace(/<%=\s*([^%]+)\s*%>/g, (_m, key) => {
      const v = getNestedValue(data, key.trim());
      return v !== undefined ? v : "";
    });
  }
  if (Array.isArray(obj)) return obj.map((x) => processSimpleTemplate(x, data));
  if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([k, v]) => [k, processSimpleTemplate(v, data)]),
    );
  }
  return obj;
}
function processArrayTemplate(templateArray, data) {
  if (!Array.isArray(templateArray) || templateArray.length !== 1) {
    return templateArray.map((x) => processSimpleTemplate(x, data));
  }
  const arrayField = Object.keys(data).find((k) => Array.isArray(data[k]));
  if (arrayField && data[arrayField]?.length > 0) {
    const t = templateArray[0];
    const out = data[arrayField].map((item) => {
      const r = processSimpleTemplate(t, item);
      return r;
    });
    log("üß© [processArrayTemplate] expanded array template:", {
      items: data[arrayField].length,
    });
    return out;
  }
  return templateArray.map((x) => processSimpleTemplate(x, data));
}
function processTemplate(obj, data) {
  const isArrayCase = Array.isArray(obj) && obj.length === 1;
  const res = isArrayCase ? processArrayTemplate(obj, data) : processSimpleTemplate(obj, data);
  if (ENABLE_LOGS) {
    const preview =
      typeof res === "string"
        ? res.slice(0, 80)
        : Array.isArray(res)
          ? `[array x${res.length}]`
          : res && typeof res === "object"
            ? "{object}"
            : String(res);
    log("üß™ [processTemplate] done:", { arrayCase: isArrayCase, preview });
  }
  return res;
}

// ============= ID Mapping (single source of truth) ============
/**
 * ÊääÂØπË±°ÈáåÊâÄÊúâ **key & string ÂÄº** ‰∏≠ÁöÑÊóß id Êò†Â∞Ñ‰∏∫Êñ∞ id„ÄÇ
 * Ê≥®ÊÑèÔºöËøîÂõûÊñ∞ÂØπË±°Ôºå‰∏ç‰ºöÂéüÂú∞‰øÆÊîπ‰º†ÂÖ•ÂØπË±°„ÄÇ
 */
function applyIdMapDeep(obj, idMap) {
  if (!obj || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((v) => applyIdMapDeep(v, idMap));
  const out = {};
  for (const [k, v] of Object.entries(obj)) {
    const newKey = idMap.get(k) || k;
    if (typeof v === "string" && idMap.has(v)) {
      out[newKey] = idMap.get(v);
    } else {
      out[newKey] = applyIdMapDeep(v, idMap);
    }
  }
  return out;
}

/** Áî®‰∏Ä‰∏™‰∏¥Êó∂ idMapÔºàfrom‚ÜítoÔºâÂØπÁõÆÊ†áÂØπË±°ËøõË°åÂ∞±Âú∞ÊõøÊç¢Ôºà‰æø‰∫é slot ÊõøÊç¢ÂêéÂêåÊ≠• configÔºâ */
function remapIdsInPlace(obj, fromId, toId) {
  const map = new Map([[fromId, toId]]);
  const remapped = applyIdMapDeep(obj, map);
  // ÂéüÂú∞Ë¶ÜÁõñ
  if (Array.isArray(obj)) {
    obj.length = 0;
    remapped.forEach((x) => obj.push(x));
  } else if (obj && typeof obj === "object") {
    Object.keys(obj).forEach((k) => delete obj[k]);
    Object.entries(remapped).forEach(([k, v]) => {
      obj[k] = v;
    });
  }
  log("üîÅ [remapIdsInPlace] remapped:", { fromId, toId });
}

// ============= Section Instantiation ============
function ensureCustomComponentConfig(section) {
  if (section.component === "custom-component") {
    section.config = { useCache: true, ...section.config };
    log("‚öôÔ∏è  [ensureCustomComponentConfig] applied default config for custom-component:", {
      id: section.id,
    });
  }
  return section;
}

/**
 * Ê∑±Â∫¶ clone Ê®°Êùø sectionÔºåÂπ∂ÁîüÊàêÁ®≥ÂÆö idÔºö
 * - ÂèÇ‰∏éÂõ†Â≠êÔºötemplateId / ÂéüÊ®°Êùø section.id / sectionIndex / pathÔºàÂê´ list Á¥¢ÂºïÔºâ
 * - clone ÂÆåÊàêÂêéÔºöÁî® idMap ÂØπ {sections/sectionIds/config...} ÂÅö‰∏ÄÊ¨°ÊÄßÂÖ®ÊõøÊç¢
 */
function cloneTemplateSection(section, { templateId, sectionIndex, path = [] }, idMap) {
  const cloned = _.cloneDeep(section);

  const derivedId = generateDeterministicId(
    JSON.stringify({ templateId, templateSectionId: section.id, sectionIndex, path }),
  );
  idMap.set(section.id, derivedId);
  cloned.id = derivedId;

  // ÈÄíÂΩíÂ§ÑÁêÜÂ≠ê section
  if (cloned.sectionIds && cloned.sections) {
    const nextSections = {};
    const nextIds = [];
    cloned.sectionIds.forEach((cid, idx) => {
      const childTpl = section.sections?.[cid];
      if (!childTpl) {
        logError("‚ö†Ô∏è  [cloneTemplateSection] missing child template:", { cid, parent: section.id });
        return;
      }
      const childClone = cloneTemplateSection(
        childTpl,
        { templateId, sectionIndex, path: [...path, idx] },
        idMap,
      );
      nextSections[childClone.id] = childClone;
      nextIds.push(childClone.id);
    });
    cloned.sections = nextSections;
    cloned.sectionIds = nextIds;
  } else {
    delete cloned.sections;
    delete cloned.sectionIds;
  }

  ensureCustomComponentConfig(cloned);

  // Áªü‰∏ÄÊõøÊç¢Ôºö‰ªª‰Ωï key/ÂÄºÈáåÂá∫Áé∞Êóß id ‚Üí Êñ∞ id
  cloned.sections = applyIdMapDeep(cloned.sections, idMap);
  cloned.sectionIds = (cloned.sectionIds || []).map((id) => idMap.get(id) || id);
  cloned.config = applyIdMapDeep(cloned.config, idMap);

  if (ENABLE_LOGS) {
    // ÊâìÂç∞Â∞ëÈáèÊò†Â∞ÑÔºàÊúÄÂ§ö 5 ‰∏™ÔºâÔºåÈÅøÂÖçËøáÂ∫¶Âô™Â£∞
    const mapPreview = [];
    let c = 0;
    for (const [from, to] of idMap.entries()) {
      mapPreview.push([from, "‚Üí", to]);
      if (++c >= 5) break;
    }
    log("üß¨ [cloneTemplateSection] cloned", {
      templateId,
      sectionIndex,
      path: fmtPath(path),
      newId: cloned.id,
      idMapPreview: mapPreview,
    });
  }

  return cloned;
}

function instantiateComponentTemplate({ component, sectionData, sectionIndex, path = [] }) {
  const templateId = component.id || component.componentId || component.name;
  if (!component?.section) {
    logError("‚ö†Ô∏è  [instantiateComponentTemplate] component has no section:", {
      templateId,
      path: fmtPath(path),
    });
    return { section: null, idMap: new Map(), dataSource: {} };
  }

  const idMap = new Map();
  const clonedSection = cloneTemplateSection(
    component.section,
    { templateId, sectionIndex, path },
    idMap,
  );

  const transformedDataSource = {};
  const tplDS = component.dataSource || {};
  Object.entries(tplDS).forEach(([origId, t]) => {
    const newId = idMap.get(origId);
    if (!newId) {
      logError("‚ö†Ô∏è  [instantiateComponentTemplate] dataSource id missing in idMap:", {
        templateId,
        origId,
      });
      return;
    }
    const processed = processTemplate(_.cloneDeep(t), sectionData);
    if (processed !== undefined && !(typeof processed === "object" && _.isEmpty(processed))) {
      transformedDataSource[newId] = processed;
    }
  });

  log("‚úÖ [instantiateComponentTemplate] instantiated:", {
    templateId,
    sectionIndex,
    path: fmtPath(path),
    sectionId: clonedSection.id,
    dsKeys: Object.keys(transformedDataSource).length,
  });

  return { section: clonedSection, idMap, dataSource: transformedDataSource };
}

// ============= Layout-block Slot Helpers ============
const isLayoutBlock = (sec) =>
  !!sec && (sec.component === "layout-block" || sec.type === "layout-block");

// ‰ªÖÂ§ÑÁêÜ {{LIST_KEY.N}} ÂΩ¢ÂºèÔºõËã•Êú™Êù•ÈúÄË¶Å {{features.LIST_KEY.N}} ÂèØÊâ©Â±ïÊ≠§Ëß£Êûê
function parseListIndexFromName(name) {
  if (typeof name !== "string") return null;
  const m = name.match(/^\s*\{\{\s*list\.(\d+)\s*\}\}\s*$/);
  return m ? Number(m[1]) : null;
}

/** Ê∑±Â∫¶ÈÅçÂéÜÁà∂ÂÆû‰æãÔºåÊî∂ÈõÜÊâÄÊúâ layout-block ÁöÑ {{LIST_KEY.N}} Âç†‰Ωç ‚Üí Map<N, {parent, placeholderId, position}> */
function collectLayoutSlots(rootSection) {
  const slots = new Map();
  function dfs(node, parent = null) {
    if (!node) return;
    if (isLayoutBlock(node)) {
      const idx = parseListIndexFromName(node.name);
      if (idx !== null && parent && parent.sections && parent.sectionIds) {
        const pos = parent.sectionIds.indexOf(node.id);
        if (pos !== -1 && !slots.has(idx)) {
          slots.set(idx, { parent, placeholderId: node.id, position: pos });
          log("üìå [collectLayoutSlots] slot found:", {
            listIndex: idx,
            placeholderId: node.id,
            parentId: parent.id,
            position: pos,
          });
        }
      }
    }
    if (node.sectionIds && node.sections) {
      node.sectionIds.forEach((cid) => dfs(node.sections[cid], node));
    }
  }
  dfs(rootSection, null);
  return slots;
}

/** ‰ªéÂ≠êËäÇÁÇπ path ‰∏≠ÊèêÂèñ list Á¥¢ÂºïÔºà‚Ä¶,"list", N, ‚Ä¶Ôºâ */
function extractListIndexFromPath(path) {
  const i = path.findIndex((p) => p === LIST_KEY);
  if (i === -1 || i + 1 >= path.length) return null;
  const v = path[i + 1];
  const n = typeof v === "number" ? v : Number(v);
  return Number.isFinite(n) ? n : null;
}

/** Áî®Â≠êÂÆû‰æãÊõøÊç¢Âç†‰ΩçÔºöÂêåÊ≠• sections/sectionIdsÔºåÂπ∂Êää parent.config ‰∏≠Âç†‰Ωç id ÂÖ®ÈáèÊõøÊç¢‰∏∫Â≠êÂÆû‰æã id */
function replaceSlotWithChild(slot, childSection) {
  const { parent, placeholderId, position } = slot;

  if (!parent.sections) parent.sections = {};
  if (!parent.sectionIds) parent.sectionIds = [];

  // 1) ÊõøÊç¢ sectionIds ÁöÑ‰ΩçÁΩÆ
  if (position >= 0 && position < parent.sectionIds.length) {
    parent.sectionIds.splice(position, 1, childSection.id);
  } else {
    logError("‚ö†Ô∏è  [replaceSlotWithChild] unexpected slot position:", {
      placeholderId,
      parentId: parent.id,
      position,
    });
    parent.sectionIds.push(childSection.id);
  }

  // 2) Êõ¥Êñ∞ sections Êò†Â∞ÑÔºöÂà†Èô§Âç†‰Ωç ‚Üí ÊåÇÊñ∞ child
  delete parent.sections[placeholderId];
  parent.sections[childSection.id] = childSection;

  // 3) ÂêåÊ≠• config ‰∏≠ÂØπÂç†‰Ωç id ÁöÑÊâÄÊúâÂºïÁî®ÔºàgridSettings Á≠âÔºâ
  if (parent.config) remapIdsInPlace(parent.config, placeholderId, childSection.id);

  log("üîó [replaceSlotWithChild] slot replaced:", {
    parentId: parent.id,
    placeholderId,
    childId: childSection.id,
  });
}

// ============= Tree BuildÔºàÂè™ÊääÁúüÂÆû list ÂΩì‰ΩúÂ≠êËäÇÁÇπÔºõÂç†‰ΩçÂùó‰∏çÂΩìÂ≠êËäÇÁÇπÔºâ ============
function collectSectionsHierarchically(section, path = []) {
  const node = { section, path, children: [] };
  // ‰∏•Ê†ºÔºöÂè™ÊúâÂΩì section[list] ÊòØÊï∞ÁªÑÊó∂ÔºåÊâçÊääÂÖ∂ÂÖÉÁ¥†ËßÜ‰∏∫ list Â≠êËäÇÁÇπ
  if (Array.isArray(section?.[LIST_KEY])) {
    section[LIST_KEY].forEach((item, idx) => {
      node.children.push(collectSectionsHierarchically(item, [...path, LIST_KEY, idx]));
    });
  }
  // Ê≥®ÊÑèÔºöÂêçÂ≠ó‰∏∫ "{{list.N}}" ÁöÑÂ∏ÉÂ±ÄÂùóÂè™ÊòØÊ®°ÊùøÊßΩ‰ΩçÔºå‰∏çÊòØÊï∞ÊçÆÔºå‰∏çÊîæËøõ children
  return node;
}

// ============= Per-node ProcessingÔºàÈÄíÂΩí + Á≤æÁ°ÆÊèíÊßΩÊõøÊç¢Ôºâ ============
function processNode(node, compositeComponents, sectionIndex) {
  const { section, path, children } = node;

  // 1) ÂåπÈÖçÁªÑ‰ª∂
  const analysis = extractFieldCombinations({ sections: [section] });
  const fieldCombinations = analysis[0]?.fieldCombinations || [];

  const matched = compositeComponents.find((c) =>
    _.isEqual((c.fieldCombinations || []).sort(), fieldCombinations.sort()),
  );

  if (ENABLE_LOGS) {
    log("üîé [processNode] match try:", {
      path: fmtPath(path),
      sectionName: section?.name,
      fcCount: fieldCombinations.length,
      matched: !!matched,
      matchedName: matched?.name || matched?.id || null,
    });
  }

  let instantiation = null;

  if (matched) {
    try {
      instantiation = instantiateComponentTemplate({
        component: matched,
        sectionData: section,
        sectionIndex,
        path,
      });
    } catch (e) {
      logError("‚ùå [processNode] instantiate failed:", {
        path: fmtPath(path),
        error: e?.message,
      });
    }
  } else {
    log("üü° [processNode] no component matched, skip instantiation:", { path: fmtPath(path) });
  }

  const result = {
    section,
    path,
    component: matched,
    instantiation,
    matched: !!matched,
    children: [],
  };

  // 2) Âè™ÊúâÁà∂Â∑≤ÂÆû‰æãÂåñÊó∂ÔºåÊâçÊî∂ÈõÜ slotÔºàÂú®Áà∂ÂÆû‰æãËåÉÂõ¥ÂÜÖÔºâ
  const slotMap = instantiation?.section ? collectLayoutSlots(instantiation.section) : new Map();

  // 3) ÈÄíÂΩíÂ§ÑÁêÜÂ≠êËäÇÁÇπÔºåÂπ∂Êåâ slot Á≤æÁ°ÆÊõøÊç¢Ôºà‰∏•Ê†ºÊåâÊú¨Áà∂ËäÇÁÇπ children ÁöÑÁ¥¢ÂºïÔºâ
  children.forEach((childNode, idx) => {
    const childResult = processNode(childNode, compositeComponents, idx);
    result.children.push(childResult);

    if (!childResult.instantiation?.section || !instantiation?.section) return;

    const childSection = childResult.instantiation.section;
    const listIdx = extractListIndexFromPath(childNode.path);

    if (listIdx !== null && slotMap.has(listIdx)) {
      replaceSlotWithChild(slotMap.get(listIdx), childSection);
    } else {
      // Êâæ‰∏çÂà∞ slotÔºö‰∏∫‰∫ÜÈÅøÂÖçÂÜçÊ¨°ÊääÂ≠êÂÆû‰æã‚ÄúÊåÇÂà∞Â§ñÈù¢‚ÄùÔºåËøôÈáå‰ªÖËÆ∞ÂΩïÂëäË≠¶Ôºå‰∏çÂÅö fallback append
      logError("‚ö†Ô∏è  [processNode] no slot matched for child, skipped mounting:", {
        parentPath: fmtPath(path),
        childPath: fmtPath(childNode.path),
        childId: childSection.id,
      });
    }
  });

  return result;
}

// ============= ComposeÔºà‰∏ÄÂè£Ê∞îÊêûÂÆöÂåπÈÖç & ÈÄíÂΩíÊåÇËΩΩÔºâ ============
function composeSectionsWithComponents(middleFormatContent, componentLibrary) {
  const parsed =
    typeof middleFormatContent === "string" ? parse(middleFormatContent) : middleFormatContent;
  if (!parsed?.sections) {
    logError("‚ö†Ô∏è  [compose] middle content has no sections");
    return { roots: [], flat: [] };
  }

  const compositeComponents = (componentLibrary || []).filter((c) => c.type === "composite");
  log("üß± [compose] start:", {
    sections: parsed.sections.length,
    compositeCount: compositeComponents.length,
  });

  const roots = parsed.sections?.map((s, i) =>
    processNode(collectSectionsHierarchically(s, ["root", i]), compositeComponents, i),
  );

  const flat = [];
  (function flatten(nodes) {
    nodes.forEach((n) => {
      flat.push(n);
      if (n.children?.length) flatten(n.children);
    });
  })(roots);

  const matchedCount = flat.filter((x) => x.matched).length;
  log("‚úÖ [compose] matching completed:", {
    matched: matchedCount,
    total: flat.length,
    ratio: `${matchedCount}/${flat.length}`,
  });
  return { roots, flat };
}

// ============= Main Entrypoint ============
export default async function composePagesData(input) {
  const {
    middleFormatFiles,
    componentLibrary,
    locale,
    translateLanguages = [],
    pagesDir,
    outputDir,
    tmpDir,
  } = input;

  try {
    rmSync(outputDir, { recursive: true, force: true });
    log("üßπ [composePagesData] clean outputDir:", { outputDir });
  } catch (e) {
    logError("‚ö†Ô∏è  [composePagesData] clean outputDir failed:", { outputDir, error: e?.message });
  }

  log("üîß [composePagesData] start:", {
    pagesDir,
    components: componentLibrary?.length || 0,
    locale,
    translateLanguages,
  });

  const allPagesKitYaml = [];
  const fileDataMap = new Map();

  if (Array.isArray(middleFormatFiles)) {
    // ÁªÑË£ÖÂ§öËØ≠Ë®ÄÂ§ÑÁêÜÈòüÂàó
    const filesToProcess = [
      ...middleFormatFiles.map((f) => ({ ...f, language: locale, isMainLanguage: true })),
      ...(translateLanguages && tmpDir
        ? translateLanguages.flatMap((lang) =>
            middleFormatFiles.map((f) => ({
              filePath: f.filePath,
              content: null,
              language: lang,
              isMainLanguage: false,
            })),
          )
        : []),
    ];

    log("üìö [composePagesData] filesToProcess:", {
      count: filesToProcess.length,
      main: filesToProcess.filter((f) => f.isMainLanguage).length,
      i18n: filesToProcess.filter((f) => !f.isMainLanguage).length,
    });

    for (const file of filesToProcess) {
      let content = file.content;
      if (!file.isMainLanguage) {
        content = await readMiddleFormatFile(tmpDir, file.language, file.filePath);
      } else if (typeof content === "string") {
        try {
          content = parse(content);
        } catch (e) {
          logError("‚ùå [composePagesData] parse main content failed:", {
            file: file.filePath,
            error: e?.message,
          });
          continue;
        }
      }
      if (!content) {
        logError("‚ö†Ô∏è  [composePagesData] skip empty content:", {
          file: file.filePath,
          lang: file.language,
        });
        continue;
      }

      const { roots, flat } = composeSectionsWithComponents(content, componentLibrary);

      if (!fileDataMap.has(file.filePath)) {
        fileDataMap.set(file.filePath, {
          filePath: file.filePath,
          meta: content.meta,
          locales: {},
          sections: {},
          sectionIds: [],
          dataSource: {},
        });
      }
      const fd = fileDataMap.get(file.filePath);

      // Êú¨Âú∞Âåñ‰ø°ÊÅØ
      fd.locales[file.language] = {
        backgroundColor: "",
        style: { maxWidth: "custom:1560px", paddingY: "large", paddingX: "large" },
        title: content.meta?.title,
        description: content.meta?.description,
        image: content.meta?.image,
        header: { sticky: true },
      };

      // È°∂Â±Ç‰ªÖÊåÇÊ†πÂÆû‰æãÔºõÂ≠êÂÆû‰æãÂ∑≤Âú®Áà∂ÂÆû‰æãÂÜÖÊåâ slot ÊõøÊç¢ÔºåÊó†ÈúÄÈáçÂ§çÊåÇËΩΩ
      if (file.isMainLanguage) {
        roots.forEach((r) => {
          const s = r.instantiation?.section;
          if (!s) return;
          fd.sections[s.id] = s;
          if (!fd.sectionIds.includes(s.id)) fd.sectionIds.push(s.id);
        });
        log("üå≤ [composePagesData] root instances attached:", {
          file: file.filePath,
          roots: roots.filter((r) => !!r.instantiation?.section).length,
        });
      }

      // dataSourceÔºöÁªü‰∏ÄËÅöÂêàÔºàÊâÄÊúâËäÇÁÇπÔºâ
      let dsAdded = 0;
      flat.forEach(({ instantiation }) => {
        if (!instantiation) return;
        Object.entries(instantiation.dataSource || {}).forEach(([id, data]) => {
          if (!id || data === undefined) return;
          if (!fd.dataSource[id]) fd.dataSource[id] = {};
          fd.dataSource[id][file.language] = _.cloneDeep(data);
          dsAdded++;
        });
      });
      log("üç± [composePagesData] dataSource aggregated:", {
        file: file.filePath,
        lang: file.language,
        added: dsAdded,
        totalKeys: Object.keys(fd.dataSource).length,
      });
    }

    // ËæìÂá∫ YAML
    fileDataMap.forEach((fd) => {
      const now = new Date().toISOString();
      const yaml = {
        id: generateDeterministicId(fd.filePath),
        createdAt: now,
        updatedAt: now,
        publishedAt: now,
        isPublic: true,
        locales: fd.locales,
        sections: fd.sections,
        sectionIds: fd.sectionIds,
        dataSource: fd.dataSource,
      };
      const content = stringify(yaml, { aliasDuplicateObjects: false });
      allPagesKitYaml.push({
        filePath: fd.filePath,
        content,
      });
      log("üìù [composePagesData] yaml prepared:", {
        file: fd.filePath,
        sectionCount: Object.keys(fd.sections || {}).length,
        rootIds: fd.sectionIds.length,
        dsKeys: Object.keys(fd.dataSource || {}).length,
      });
    });
  } else {
    logError("‚ö†Ô∏è  [composePagesData] middleFormatFiles is not an array");
  }

  // ‰øùÂ≠òËæìÂá∫
  allPagesKitYaml.forEach(({ filePath, content }) => {
    try {
      savePagesKitData({
        path: basename(filePath).split(".")?.[0] || filePath,
        locale,
        pagesDir,
        pagesKitYaml: content,
        outputDir,
      });
      log("üíæ [composePagesData] saved:", { file: filePath, bytes: content.length });
    } catch (e) {
      logError("‚ùå [composePagesData] save failed:", { file: filePath, error: e?.message });
    }
  });

  log("üéâ [composePagesData] done");
  return { ...input };
}

composePagesData.taskTitle = "Compose Pages Data";
